Following are some intellectual tools that I used to help me design WebPy. I primarily drew from Cognitive Dimensions:

Closeness of Mapping (Cognitive Dimensions). The cognitive dimensions paper describes closeness of mapping as the relationship between the algorithm or task in the programmer's mind and the code that they must write to express that algorithm or task. My consumer is an experienced web-developer, so he is adroit at transforming his internal vision of a website into HTML, CSS, JavaScript, or Python. Therefore, in my design I should strive to keep the feel or structure of these languages, and not attempt to invent a radically new notation.

Terseness (Cognitive Dimensions). It would be beneficial to include a layer of abstraction over some commonly rewritten code, if I can do it without making my design worse in terms of other dimensions (e.g. Hidden Dependencies). In particular, this justifies my decision to abstract the communication between the client and the server through HTTP requests and responses.

Error-Proneness (Cognitive Dimensions). Parsing information can require a somewhat complex algorithm. By eliminating the need for my programmer to parse out data structures passed through HTTP requests and responses, I hope to reduce the chance of him committing any programming errors through this sometimes unnatural process.

Visibility (Cognitive Dimensions). My consumer often develops small websites, or websites simply for testing purposes. For these applications, it is not important that his code be separated into HTML skeleton, CSS style, client-side JavaScript, and server-side Python files for modularity and reuse purposes. This means that having all of this code in a single file, as my design allows, improves code visibility at no cost. One site, in one file, in one tab in his IDE.

Aggregate Queries and Operations (Natural Programming). The natural programming paper discussed the difficulty that many programmers have with the concept of iteration, and how many programmers find it cognitively easier to query and operate on groups of elements in aggregate. For this reason, I wanted to find a notation that would allow my user to do something similar to JQuery's selector functionality, which gives JavaScript programmers the ability to query and operate on DOM elements in aggregate. I remembered that my consumer uses Django, which  includes a similar functionality that allows querying on SQL elements, so I decided to include a similar syntax to help represent JQuery.
